.. index:: 型

.. _型:

型
==============
組み込みで使用されるC言語の型について

概要
-----------
| 組み込みで使用するC言語の型は一定の書式がある為、見慣れないうちは戸惑うと思われる。
| ここではその一覧とそうなっている理由について記述する。

必ずtypedefされた型を使用する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
| 全てのソースコードが参照するヘッダ内に、下記のような使用する型のtypedefが並んでいるはずである。

.. code-block:: c
    :linenos:

    typedef unsigned char   uint8;  /* uchar, BYTEとも */
    typedef unsigned short  uint16; /* ushort, WORD, HWORDとも */
    typedef unsigned int    uint32; /* uint, DWORD, WORDとも */
    typedef unsigned long   uint64; /* ulongとも */
    typedef signed char     int8;
    typedef signed short    int16;
    typedef signed int      int32;
    typedef signed long     int64;

| マイコンには命令のbit数があり、使用するint型が必ずしも32bitではない為である。
| その為、マイコンを載せ替えても動作するようにこのtypedefで差分を吸収する。
| 実際静的解析でもC言語の基本の型を直接使用していると警告が出る。
| またマイコンのマニュアルでも表現方法が他のマイコンと異なる場合が多々ある。
| コード中のWORD、HWORD(HALF WORD)、DWORD(DOUBLE WORD)はその最たる例である。
| 以下はその説明である。

.. csv-table:: マイコンマニュアル上の型付け
    :header-rows: 1

    マイコン, 2Byte, 4Byte, 注釈
    A, WORD, DWORD, WORDが2バイトなのでその2倍としてDOUBLE WORD
    B, HWORD, WORD, WORDが4バイトなのでその半分としてHALF WORD

| 上記のような表記揺れがある為、マイコンが変わった時はどの型がどのサイズになるのかを把握する事。

基本的にsignedは使用しない
^^^^^^^^^^^^^^^^^^^^^^^^^^
| マイコン上で行われる演算には基本的に負の値を使用しない。
| 理由はぱっとあげて以下のようなものがある。

* 単純な制御には基本的に負の値を使用しない。
* 通信に乗せるデータはバイナリ値であり、そのまま取得するとunsignedである。
* ビットシフトやキャストを行った際に、 **マイコンによって最上位ビットの扱いが変わる** 。

基本的に浮動小数点は使用しない
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
| マイコン上で行われる演算には基本的に浮動小数点を使用しない。
| 理由はぱっとあげて以下のようなものがある。

* マイコンのレジスタから取得できるデータはバイナリ値である。
    たとえ使用していてもレジスタを介す保存、取得、通信時には別のバイナリ列に変換される。

* 単純な制御では小数点以下の演算結果が不要である [1]_ 。
* 浮動小数点演算は通常の演算に比べ非常に時間がかかる [2]_ 。



.. [1] そもそも浮動小数点を使用しなさいと明記がある仕様を見た事が無い。
.. [2] 浮動小数点演算用回路(FPU等)を搭載しているとそれなりにマシになる、が、遅いものは遅い。そもそもあるかどうかもマイコン依存である。
