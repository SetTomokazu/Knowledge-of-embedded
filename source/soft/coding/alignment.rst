
.. index:: Alignment

.. _Alignment:

Alignment
==============
| 分かり易くは　`外部記事 <http://ertl.jp/~takayuki/readings/info/no01.html>`_ 参照

**データはアクセスサイズの整数倍のアドレスからしか取得できない。**

| つまり、2byteのデータを読み書きする場合は アドレスが偶数でないと取得できない。
| int型の4byteを読み書きする際はアドレスが4の倍数である必要がある。
| それ以外の個所へ読み書きしようとすると基本的にエラーになる。

| 例えば以下のようにアドレスにデータが格納されているとする。

+--------+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
|Address | 0| 1| 2| 3| 4| 5| 6| 7| 8| 9| A| B| C| D| E| F|
+========+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+==+
|Data    |01|02|03|04|05|06|07|08|09|0A|0B|0C|0D|0E|0F|10|
+--------+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

| この時、アドレス1から4バイトのデータは 0x02030405 であるが、
| これを取るためにint型でアクセスは基本的に出来ない。

.. note::
    この時のエラーはマイコンによって異なる。
    見聞きしたことがあるのは以下の3通り

    * 例外を出力する。
    * その次の正しいAlignmentへ読み書きし、そのまま動く。
    * はみ出ている部分を全て取得し、マイコンが自力で演算して正しい値を使用する。
        | このマイコンの時のみ、上記の0x02030405が取得できる。
        | が、これを当てにしたプログラムを書くと移植時の不具合の基になる為やらないこと。

.. index:: 境界値調正

.. _境界値調正:

境界値調正
-----------------
| コンパイラが :ref:`Alignment` を守る為に、構造体に詰め物をすること。
| 以下は境界値調正される構造体とその結果の例である。

.. code-block:: c

    /* 例1 */
    /* before */
    typedef struct {
        char    byte;
        int     word;
    } hoge_t;

    /* after */
    typedef struct {
        char    byte;
        char    dummy[3];   /* wordを4byteAlignmentに配置させるためのオフセット */
        int     word;
    } hoge_t;

.. code-block:: c

    /* 例2 */
    /* before */
    typedef struct {
        char    byte1;
        short   hword;
        char    byte2;
    } hoge_t;

    /* after */
    typedef struct {
        char    byte1;
        char    dummy1;     /* hwordを4byte :ref:`Alignment` に配置させるためのオフセット */
        short   hword;
        char    byte2;
        char    dummy2;     /* hoge_tのサイズを2byte :ref:`Alignment` に適合させるためのおまけ */
    } hoge_t;

.. warning:: 様々な型を内包した構造体は、一番サイズの大きい型の整数倍にサイズが調整される。

| このため、例えば例2の構造体において
| 構造体をパッと見ただけでは4byteだが、sizeofを行った結果は6byteになる。
| この為むやみやたらとmemcpyやキャストを行うと、想定外のアドレスへアクセスしていたり、
| 期待と違った値が読み出せたりするため大変危険である。
| 構造体を記述する際は常に隙間が空かないように注意する事。
