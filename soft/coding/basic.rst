.. index:: C言語の標準仕様

.. _C言語の標準仕様:

C言語の標準仕様
============================



.. index:: bit演算

.. _bit演算:

bit演算
-------------
| 主にレジスタの値を編集するためによく使用される。
| CPUが内部でどのような処理をしているのかについて説明する。

.. code-block:: c

    P_HOGE_REG |= 0x40;

| といった演算があった場合、単にレジスタの値の6bit目を1にしているだけではない。
| そもそもCPUは最低でも1byteサイズでしかメモリにアクセスできない為、
| C言語上で省略されていても内部ではこのように処理される。

.. code-block:: c
    :linenos:

    unsigned char tmp;

    tmp = P_HOGE_REG;
    tmp = tmp | 0x40;
    P_HOGE_REG = tmp;

| この時、3行目と5行目の間で他のbitが変更されていても
| 5行目の処理によって以前の値に上書きしてしまう。
| それを回避するために、レジスタ等複数から同時にアクセスされる恐れのあるものについては、
| 制御中は割り禁を行うことがルールとなっている。



.. index:: 割り込み関数

.. _割り込み関数:

割り込み関数
-------------
| 割り込みで使用される関数のことだが、他の関数とは異なる定義をする必要がある。
| それはコンパイル時にこれは通常の関数でなく割り込み関数ですよと明示する事である。
| 通常の関数がサブ関数をCallする場合は、Stackに以下のものを積んでCallする。

* 引数
    実行するために必要

* Callしたアドレス
    実行後に元の関数へ戻ってくるためのメモ書き

* 戻り値を格納する領域
* 現在のローカル変数
* Callした時のStackアドレス
    実行後に元の関数の処理を復旧させるためのメモ書き

| これは、Call後にCall元の関数へ現状復帰する為のメモ書きである。
| しかし、割り込み関数のCall元は現在実行中の処理ではなくマイコン自身となる為、
| この積む内容が少々異なる。
| また、復帰用の記述もC言語上は同じであるが、アセンブラレベルの記述は異なることになる。
| その為、割り込み関数はそういった特殊な関数であることを明示する必要がある。
| その例は以下のようなものがある。

.. code-block:: c

    /* プリプロセッサによる指定 */
    #pragma intterupt
    void interruput_func(void) { ... }

.. code-block:: c

    /* 独自の型による指定 */
    _interrupt void interruput_func(void) { ... }

.. note::
    割り込み関数は他の通常関数や割り込み関数からCallしてはいけない！！！！
