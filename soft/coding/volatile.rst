.. index:: volatile

.. _volatile:

volatile
===========
| コンパイルする際のオプションで最適化というものがある。
| これはアセンブラレベルでのソースの簡略化や共通化によってコード量を減らしたり高速化したりすることである。
| 尚それをされると非常に面倒なことがあったりする。
| 組み込み開発でソースの簡略化による影響で大きいものを二つ紹介する。

**配列や構造体の簡略化**
    | 連続して同じ値が入っているテーブルが簡略化され、それ以降の配置が詰められたり
    | 構造体で未使用のメンバを削除されたりする。
    | :ref:`ベクタテーブル` 等は、そのメモリアドレスに配置されている事自体が重要である為、
    | そういった事に絡む定義は悉くvolatileが使用されている。

**ソースの不要処理削除**
    | 大抵のレジスタは値をWriteすればその瞬間からその通り動作する。
    | しかし、一部のレジスタはそれだけではすぐに反映されないものがある。
    | そういったレジスタは、反映させるにはReadしてソフトで使用しなさいと指示がある物がある。
    | その記述は例えば以下の様になり、ソースだけ見ると目的が分からない記述になる。

    .. code-block:: c
        :linenos:

        volatile void main(void) {
            unsigned char tmp;

            hoge_Data_Register = 0xA5;  /* レジスタに値Write */

            tmp = hoge_Data_Register;   /* レジスタ値をRead */
            tmp = tmp;                  /*  ...んん? */

            /* それ以降の処理... */

        }

    | tmpにレジスタの値を読み込んでいるが、7行目のtmp = tmpで特に何もしておらず、それ以降もtmpは使用されない。
    | これに最適化がかかると、まず7行目が不要行として削除される可能性がある。
    | そして、読み込んだデータを使用しなくなる為6行目も削除される可能性がある。
    | この簡略化を防ぐために、こういったレジスタを制御する関数にもvolatileが使用される。
