.. index:: STACK

.. _STACK:

STACK(スタック)
============================
| 名前だけは聞いたことがあるけど特に中身を知らないSTACK。
| とりあえず :ref:`Assembly` を参考にしつつ以下のソースコードを見てほしい。

.. code-block:: c
    :linenos:

    int add(int a, int b) {
        int result;
        result = a + b;
        return result;
    }

    void main(void) {
        int a = 5;
        int b = 6;
        int c = 0;
        c = add(a, b);
        printf("%d\n", c);
        return;
    }

| プログラムは7行目から開始し、
| 11行目の時点で一度1行目へジャンプする。
| そして、17行目まで終わってから再度11行目に戻ってくるわけだが、
| ……一体どうやってプログラムは11行目に戻ってこれるんですかね。
| まず1行目にジャンプするのは簡単である。
| なぜなら :ref:`Linker` が走った時点でadd関数のアドレスは定まる為、
| そのまま11行目に相当する個所にそのアドレスを書き込めば :ref:`PC` は飛んでくれる。
| しかし、add関数が終わった時点でのジャンプ先はadd関数には分からない。
| 一体どうすれば……。
| そこでSTACKさんの出番である。
| Call時点の :ref:`PC` アドレスを保存し、return時にはそこに復帰するようにする。
| これで関数Callが成立するようになる。
| なお他にも色々と情報を積んでいる。

* Callした時点のアドレス
    実行後に元の場所へ戻ってくるためのメモ書き

* Call先関数に渡す引数
    実行するために必要

* Call先関数から受け取る戻り値

* Callした時点での現在のローカル変数
* Callした時点でのStackアドレス
    実行後にCall元関数の処理を復旧させるためのメモ書き
